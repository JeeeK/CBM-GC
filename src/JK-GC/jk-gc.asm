*= $C500
!to "jk-gc.o", cbm	; set output file and format
;
;.OPT LIST,NOSYM
;
; *************************
; *  GARBAGE  COLLECTION  *
; *   VON JOHANN KLASEK   *
; * 1985-12-27 VERS. 1.1  *
; * 2013-11-24 VERS. 2.0  *
; *************************
;
; AUFRUF: SYS ...
; RÄUMT STRINGSPEICHER AUF
; ES WERDEN NUR JENE SPEICHERSTELLEN
; BENUTZT, DIE AUCH DIE NORMALE
; GC VERWENDET; ALLE ANDEREN
; WERDEN WIEDER RESTAURIERT.

; BASIC SYSTEMVARIABLEN

TOSS     = $19		; TOP OF STRINGSTACK
EOSS     = $22		; END OF STRINGSTACK +1
TSSP     = $16		; TEMP. STRINGSTACK POINTER

VARTAB   = $2D		; Basicprogrammende = Variablenanfang
ARYTAB   = $2F		; Variablenende = Arraybereichanfang
STREND   = $31		; Arraybereichende = unterste Stringheap-Adresse
FRETOP   = $33		; aktuelle Stringheap-Adresse
MEMSIZ   = $37		; höchste RAM-Adresse für Basic, Start
			; des nach unten wachsenden Stringheaps
MEMBEG   = STREND	; MEMORY BEGINN = STREND
MEMEND   = MEMSIZ	; MEMORY END

; VARIABLEN

STRPTR   = FRETOP	; STRING POINTER = FRETOP
STRDP    = $22		; STRING DESCRIPTOR ADDRESS
BERANF   = $4C		; BEREICHSANFANG
NEWPTR	 = $4E		; NEUER STRING POINTER
PTR      = $50		; ARRAY POINTER
LEN      = $52		; STRING LENGTH
FLAG     = $53		; ENDE-FLAG
; $54-$56 BELEGT
STAT     = $57		; STRING STATE
; $58-5B wird von MOVBLOCK zerstört!
STRADR   = $58		; STRING ADDRESS (TEMP.)
BEREND   = $5D		; BEREICHSENDE
BUFPTR   = $5F		; BUFFER POINTER
			; (MOVBLOCK: QUELLBLOCKANFANG!)

CPTR     = $22		; POINTER FÜR INSTALL-ROUTINE

; ZU RETTENDER ZEROPAGE-BEREICH
ZPSTART  = $4C		; 1. zu rettende
ZPEND    = $53		; letzte zu rettende
ZPLEN    = ZPEND-ZPSTART+1
			; Anzahl zu rettende

; KONSTANTEN

STAT_SDS = 5
STAT_VAR = 3
STAT_ARY = 1


; SPEICHERORTE

GARBCOL  = $B526	; Einsprungpunkt GC

MOVBLOCK = $A3BF	; Block verschieben
			; zerstört $58/$59/$5A/$5B/$22

BASIC    = $A000        ; BASIC-ROM
KERNAL   = $E000        ; KERNAL-ROM
ROMSIZE  = $2000        ; ROM-Länge 8k
BUF	 = KERNAL	; Puffer unter Kernal
BUFSIZE  = ROMSIZE	; Puffergröße

; I/O-BEREICHE/-ADRESSEN

VIDBASE  = $0400	; Video RAM
COLBASE  = $D800	; Color RAM

MARKE    = "*"		; Aktivitätsanzeige
MARKEFARBE = 9		; rot
MARKEOFF = 40*25-1	; Markeposition
MARKEVID = VIDBASE+MARKEOFF
MARKECOL = COLBASE+MARKEOFF

PROZPORT = $01          ; Prozessorport
MEMROM = %00110111      ; Basic+Kernal ROM, $37
MEMBAS = %00110110      ; Basic RAM+Kernal ROM, $34
MEMRAM = %00110101      ; Basic+Kernal RAM, $35



; Installer

INSTALL
	LDA #MEMROM
	STA PROZPORT	; ALLES ROM
	LDY #<BASIC	; ROM-BEGINN
	STY CPTR
	LDA #>BASIC
	STA CPTR+1	; BASIC-ROM ANFANG
	LDX #>($2000)	; BASIC-ROM LÄNGE
CPYROM	LDA (CPTR),Y	; ROM LESEN
	STA (CPTR),Y	; RAM SCHREIBEN
	INY
	BNE CPYROM
	INC CPTR+1	; NÄCHSTE PAGE
	DEX
	BNE CPYROM
	LDA PROZPORT
	AND #%11111110	; BASIC-ROM AUS MASKE
	STA PROZPORT
	LDA #<COLLECT	; JMP COLLECT
	STA GARBCOL+1	; PATCHEN ...
	LDA #>COLLECT
	STA GARBCOL+2
	LDA #$4C	; JMP OPCODE
	STA GARBCOL
	RTS

; *** Garbage Collector

COLLECT
	LDA MARKEVID	; KONTROLLANZEIGE BILDSCHIRM
	STA ORIGVID
	LDA #MARKE
	STA MARKEVID	; MARKE ZEICHEN
	LDA MARKECOL
	STA ORIGCOL
	LDA #MARKEFARBE
	STA MARKECOL	; MARKE FARBE

	LDX #ZPLEN	; ZEROPAGE-REG.
SAVLOOP	LDA ZPSTART-1,X	; RETTEN
	STA SAVE-1,X
	DEX
	BNE SAVLOOP

	STX FLAG	; ENDEFLAG=0 (NEIN)
	LDA MEMEND	; STRING POINTER
	LDX MEMEND+1	; UND BEREICHANFANG 
	STA STRPTR	; AUF SPEICHERENDE
	STX STRPTR+1	; SETZEN
	STA BERANF
	STX BERANF+1

; *** Bereiche

NEXTBLOCK
	LDA STRPTR	; NEWPTR PARALLEL MIT
	STA NEWPTR	; BUFPTR MITZIEHEN ...
	LDA STRPTR+1
	STA NEWPTR+1
	LDX BERANF
	LDA BERANF+1	; BEREICH
	STX BEREND	; UM PUFFERLÄNGE
	STA BEREND+1	; NACH UNTEN VERLEGEN
	SEC
	SBC #(>BUFSIZE)
			; -1 PAGE XXX
	BCC LASTRANGE	; <0 (ALSO <STREND)
	STA BERANF+1
	CPX STREND	; STRINGS ENDE
	SBC STREND+1	; ERREICHT?
	BCS STRINRANGE
LASTRANGE
	INC FLAG	; JA, ENDEFLAG SETZEN
	LDA STREND	; BEREICHANFANG =
	LDX STREND+1	; SPEICHERANFANG
	STA BERANF	; BEREICHANFANG = BEREICHENDE
	STX BERANF+1	; (SONDERFALL)

	CMP BEREND	; -> BEREICH IST 0 BYTE LANG
	BNE STRINRANGE	; -> FERTIG
	CPX BEREND+1
	BNE STRINRANGE

CHECKEND
	LDA FLAG	; ENDFLAG GESETZT?
	BEQ NEXTBLOCK	; NÄCHSTEN BEREICH UNTERSUCHEN

; *** Ende

	LDX #ZPLEN	; ZEROPAGE-REG.
RESLOOP	LDA SAVE-1,X
	STA ZPSTART-1,X	; RESTAURIEREN
	DEX
	BNE RESLOOP

	LDA ORIGVID	; KONTROLLANZEIGE LÖSCH
	STA MARKEVID	; UND ALTEN ZUSTAND WIEDER HERSTELLEN
	LDA ORIGCOL
	STA MARKECOL

	RTS

STRINRANGE
!if ((BUF+BUFSIZE) and $FFFF) != 0  {
	LDA #>(BUF+BUFSIZE)
	STA BUFPTR+1
	LDA #<(BUF+BUFSIZE)
	STA BUFPTR
} else {
	LDA #0		; BUFFERPOINTER AUF
	STA BUFPTR	; $10000 (65536) = 0
	STA BUFPTR+1	; SETZEN.
}
	SEC
	!byte $24	; BIT ZP, NÄCHSTEN BEFEHL IGNORIEREN
NEXTSTR	
	CLC
NEXTSTR1
	JSR GETSA	; NÄCHSTE STRINGADRESSE HOLEN
	LDA LEN		; WENN 0, DANN
	BEQ WEITER	; KEINEN STRING MEHR GEFUNDEN!

	TYA		; HIGH BYTE
	CPX BEREND
	SBC BEREND+1	; ÜBER BEREICH
	BCS NEXTSTR	; NÄCHSTER STRING!
	TYA		; HIGH BYTE
	CPX BERANF
	SBC BERANF+1	; UNTER BEREICH
	BCC NEXTSTR1	; NÄCHSTER STRING!

	LDA BUFPTR	; STRINGLÄNGE VERSCHIEBEN
	SBC LEN
	STA BUFPTR
	BCS L4
	DEC BUFPTR+1

L4	STY STRADR+1	; STRINGADRESSE ABSPEICHERN
	STX STRADR

	LDY LEN
	DEY
	BEQ LEN1
NEXTBYT	LDA (STRADR),Y	; STRING IN DEN BUFFERBEREICH
	STA (BUFPTR),Y	; ÜBERTRAGEN
	DEY
	BNE NEXTBYT
LEN1
	LDA (STRADR),Y	; DAS 0. BYTE EXTRA
	STA (BUFPTR),Y	; 

	SEC		; NEUE STRINGADRESSE BERECHNEN!
	LDA NEWPTR
	SBC LEN
	STA NEWPTR
	BCS L5
	DEC NEWPTR+1
L5
	JSR CORR	; STRINGADRESSE IN DESCRIPTOR ÄNDERN
			; Z=0
	BNE NEXTSTR	; UNBEDINGT, NÄCHSTER STRING

WEITER	
!if ((BUF+BUFSIZE) and $FFFF) != 0  {
	LDA BUFPTR	; BUFFER LEER ...
	CMP #<(BUF+BUFSIZE)
	BNE WEITER1
	LDA BUFPTR+1	; WENN PTR AM ENDE
	CMP #>(BUF+BUFSIZE)
	BEQ CHECKEND
WEITER1
} else {
	LDA BUFPTR	; BUFFER LEER
	ORA BUFPTR+1	; WENN PTR =0 (ENDE)
	BEQ CHECKEND
}

	LDA STRPTR
	STA $58		; ZIELBLOCKENDE+1
	LDA STRPTR+1
	STA $59
	LDA NEWPTR
	STA STRPTR	; NEUES FRETOP
	LDA NEWPTR+1	
	STA STRPTR+1

!if ((BUF+BUFSIZE) and $FFFF) != 0  {
	LDA #<(BUF+BUFSIZE)
	STA $5A
	LDA #>(BUF+BUFSIZE)
	STA $5B
} else {
	LDA #$00	; QUELLBLOCKENDE+1
	STA $5A
	STA $5B
}
			; QUELLBOCKANFANG = BUFPTR

	SEI		; BETRIEBSSYS.-ROM
	LDA PROZPORT	; WEGBLENDEN
	PHA		; DAMIT RAM ZUGÄNGLICH
	LDA #MEMRAM	; WIRD

	STA PROZPORT

	JSR MOVBLOCK	; BASIC-ROUTINE BLOCKVERSCHIEBEN
			; Z=1
	PLA		; URSPRÜNGLICHER ZUSTAND
	STA PROZPORT	; KERNAL-ROM WIEDER AKTIVIEREN
	CLI
	JMP CHECKEND	; IMMER


;
; GETSA: ( C, STRDP -> STRDP, LEN, X, Y )
;

GETSA	BCC CHECKTYPE	; C=0 -> NÄCHSTEN STRING

; *** STRING DESCRIPTOR STACK (SDS)

;         belegt->|<-frei
;    +-------------+
;    |             V
;   +-+     +-----+-----+-----+
;   | |     |S|L|H|S|L|H|S|L|H|
;   +-+     +-----+-----+-----+
;    ^       ^     ^     ^     ^
;    $16     $19   $1C   $1F   $21
;    TSSP    TOSS
;
DESCSTACK
	LDY #0
	STY STRDP+1	; DESCRIPTOR AUF
	LDA #TOSS	; SDS
	STA STRDP
	LDX #STAT_SDS
	STX STAT
	BNE ISDSTEND	; IMMER
DSTACK	CLC
	LDA STRDP
NEXTDST	ADC #3
ISDSTEND
	CMP TSSP	; STACK DURCH?
	BEQ VARS
	TAX
	LDY 0,X
	BEQ NEXTDST
	STY LEN
	LDA 2,X		; STRINGADR. HIGH
	TAY
	LDA 1,X		; STRINGADR. LOW
	TAX
	RTS

; *** VARIABLEN

VARS	LDA VARTAB	; VARIABLENANFANG
	LDX VARTAB+1
	STA STRDP
	STX STRDP+1
	LDA STRDP
	LDY #STAT_VAR	; STATUS: EINFACHE VARIABLEN
	STY STAT
	BNE ISVAREND
VAR
NEXTVAR	CLC		; NÄCHSTE VARIABLE
	LDA STRDP
	ADC #7		; VARIABLENLÄNGE
	STA STRDP
	BCC ISVAREND
	INC STRDP+1
ISVAREND
	CMP ARYTAB
	BNE CHECKVAR
	LDX STRDP+1	; VAR-ENDE (=ARRAY-ANFANG)?
	CPX ARYTAB+1
	BEQ ARRAYS	; VAR.-ENDE, WEITER MIT ARRAYS
CHECKVAR
	LDY #0		; VARIABLENNAME
	LDA (STRDP),Y	; 1. ZEICHEN
	BMI NEXTVAR	; KEIN STRING, NÄCHSTE V.
	INY
	LDA (STRDP),Y
	BPL NEXTVAR	; KEIN STRING, NÄCHSTE V.
	INY
	LDA (STRDP),Y	; STRINGLÄNGE
	BEQ NEXTVAR	; = 0, NÄCHSTE V.
	STA LEN
	INY
	LDA (STRDP),Y	; ADRESSE LOW
	TAX
	INY
	LDA (STRDP),Y	; ADRESSE HIGH
	TAY
	RTS

CHECKTYPE
	LDA STAT	; GETSA FORTSETZUNGSEINSTIEG
	CMP #STAT_VAR	; STATUS STRING?
	BCC ARRAY	; =1 -> ARRAY
	BEQ VAR		; =3 -> VARIABLE
	JMP DSTACK	; =5 -> STRING DESC. STACK

ARRAYS	STA PTR		; ARRAY POINTER
	STX PTR+1
	LDY #STAT_ARY
	STY STAT	; ARRAYS STATUS
ISARREND
	LDA PTR
	LDX PTR+1
	CPX STREND+1
        BNE NEXTARR
	CMP STREND
	BEQ NOSTRING	; ARRAYS FERTIG
NEXTARR
	STA STRDP	; IMMER C=0
	STX STRDP+1
	LDY #0
	LDA (STRDP),Y	; ARRAY-NAME
	TAX		; VAR-TYP MERKEN
	INY
	LDA (STRDP),Y
	PHP		; VAR-TYP MERKEN
	INY
	LDA (STRDP),Y	; OFFSET NÄCHSTES ARRAY
	ADC PTR		; C IST BEREITS 0 (CMP/CPX)
	STA PTR		; START FOLGEARRAY
	INY
	LDA (STRDP),Y
	ADC PTR+1
	STA PTR+1
	PLP		; VAR-TYP HOLEN
	BPL ISARREND	; KEIN STRINGARRAY
	TXA		; VAR-TYP HOLEN
	BMI ISARREND	; KEIN STRINGARRAY
	INY
	LDA (STRDP),Y	; ANZAHL DER DIMENSIONEN
	ASL		; *2
	ADC #5		; OFFSET = DIM*2+5
	LDY #0
	BEQ ADVDESC
ARRAY
	LDY #0
NEXTASTR
	CLC
	LDA #3		; STRING-DESCRIPTOR-LÄNGE
ADVDESC
	ADC STRDP	; STRING WEITER
	STA STRDP
	BCC ISLASTASTR
	INC STRDP+1
ISLASTASTR
	CMP PTR		; ARRAY DURCH?
	BNE IS0ASTR
	LDX STRDP+1
	CPX PTR+1
	BEQ ISARREND
IS0ASTR
	LDA (STRDP),Y	; STR.-LÄNGE
	BEQ NEXTASTR	; WEITER IM ARRAY
	STA LEN
	INY
	LDA (STRDP),Y	; ADRESSE LOW
	TAX
	INY
	LDA (STRDP),Y	; ADRESSE HIGH
	TAY
	RTS		; IN X/Y RETOUR

NOSTRING
	LDA #0
	STA LEN
	RTS

;
; CORR ( STRADR, STAT -> )
;
CORR	LDA STAT	; STR.-ADR. KORRIGIEREN
	AND #%011	; NUR 2 BITS
	TAY		; LAGE DES DESCRIPTORS
	LDA NEWPTR	;
	STA (STRDP),Y	; ... BEI STR.-STACK
	INY		; ... UND ARRAY VERSCHIEDEN!
	LDA NEWPTR+1
	STA (STRDP),Y
	RTS

ORIGVID !byte 0		; ORIGINAL VIDEO DER MARKENPOSITION
ORIGCOL !byte 0		; ORIGINAL FARBE DER MARKENPOSITION
SAVE	!byte 0		; GESICHERTE ZP-VARIABLEN
*=*+ZPLEN-1


